#!/usr/bin/env ruby
# vim:fileencoding=utf-8

require 'fileutils'
require 'minitest/spec'
require 'net/http'
require 'json'

require 'fakesmtpd'
require 'mail'

require_relative '.golden/bits'
require_relative '.golden/hookworm_server_runner'

include Bits
include FileUtils

def current_mail_messages
  JSON.parse(
    get_request(path: '/messages', port: $fakesmtpd_server.http_port).body
  ).fetch('_embedded').fetch('messages').map { |h| h['_links']['self']['href'] }
end

def clear_mail_messages
  delete_request(path: '/messages', port: $fakesmtpd_server.http_port)
end

def post_payload(port, payload_name)
  pre_request_messages = current_mail_messages
  response = post_request(port: port, body: payload(payload_name))
  [response, current_mail_messages - pre_request_messages]
end

def last_message
  message = JSON.parse(get_request(
    path: current_mail_messages.last, port: $fakesmtpd_server.http_port
  ).body)
  return Mail.new if message['body'].nil?
  return Mail.new(message['body'].join("\n"))
end

def last_message_header(header_name)
  last_message[header_name].to_s
end

$fakesmtpd_server = FakeSMTPd::Runner.new(
  port: "#{rand(13100..13109)}",
  dir: File.expand_path('../log/emails', __FILE__),
  pidfile: File.expand_path('../log/fakesmtpd.pid', __FILE__),
  logfile: File.expand_path('../log/fakesmtpd.log', __FILE__)
)

$servers = {
  null: HookwormServerRunner.new(
    '-a' => ":#{rand(12100..12109)}",
    '-P' => File.expand_path('../log/hookworm-server-null.pid', __FILE__),
    '-D' => File.expand_path(
      "../log/hookworm-null-#{Time.now.utc.to_i}-#{$$}", __FILE__
    ),
    start: Time.now.utc,
  ),
  debug: HookwormServerRunner.new(
    '-a' => ":#{rand(12110..12119)}",
    '-d' => nil,
    '-P' => File.expand_path('../log/hookworm-server-debug.pid', __FILE__),
    '-b' => '^master$,^develop$',
    '-p' => '\.go$,\.json$',
    '-e' => "smtp://localhost:#{$fakesmtpd_server.port}",
    '-f' => 'hookworm-runtests@testing.local',
    '-r' => 'hookworm-self@testing.local',
    '-D' => File.expand_path(
      "../log/hookworm-debug-#{Time.now.utc.to_i}-#{$$}", __FILE__
    ),
    '-W' => File.expand_path('../worm.d', __FILE__),
    start: Time.now.utc,
  )
}

$servers.each do |name,server|
  mkdir_p(server.options['-D'])

  describe "#{name} server receiving hook payloads" do
    it 'accepts valid POSTs' do
      post_payload(server.port, :valid).first.code.must_equal '204'
    end

    it 'rejects invalid POSTs' do
      post_payload(server.port, :bogus).first.code.must_equal '400'
    end
  end
end

describe 'when receiving a payload for a watched branch' do
  before do
    @sent_messages = post_payload($servers[:debug].port, :rogue).last
  end

  it 'sends a rogue commit email' do
    @sent_messages.wont_be_empty
  end
end

describe 'when receiving a payload for an unwatched branch' do
  before do
    @sent_messages = post_payload(
      $servers[:debug].port, :rogue_unwatched_branch
    ).last
  end

  it 'does not send a rogue commit email' do
    @sent_messages.must_be_empty
  end
end

describe 'when receiving a payload for an unwatched path' do
  before do
    @sent_messages = post_payload(
      $servers[:debug].port, :rogue_unwatched_path
    ).last
  end

  it 'does not send a rogue commit email' do
    @sent_messages.must_be_empty
  end
end

describe 'rogue commit emails' do
  before do
    @rogue_response ||= post_payload($servers[:debug].port, :rogue).first
  end

  it 'are multipart' do
    last_message.multipart?.must_equal true
  end

  it 'are sent to the specified recipients' do
    last_message_header('To').must_equal 'hookworm-self@testing.local'
  end

  it 'are sent from the specified sender' do
    last_message_header('From').must_equal 'hookworm-runtests@testing.local'
  end

  it 'have a subject starting with [hookworm]' do
    last_message_header('Subject').must_match(/^\s*\[hookworm\]/)
  end

  it 'have a subject with the commit author name' do
    last_message_header('Subject').must_match(/Dan Buch/)
  end
end

describe 'when receiving a payload for a pull request merges' do
  describe 'without signoff' do
	it 'sends a rogue pull request email'
  end
end

def main(argv = [].freeze)
  at_exit do
    $fakesmtpd_server.stop
    $servers.each do |_,server|
      server.stop
    end
  end

  Dir.chdir(File.expand_path('../', __FILE__)) do
    mkdir_p('./log')
    $fakesmtpd_server.start
    $servers.each do |_,runner|
      runner.start
    end
  end

  clear_mail_messages

  Dir.glob("#{File.expand_path('../test', __FILE__)}/**/*_test.rb").each do |f|
    require f
  end

  exit_code = 1

  Dir.chdir(File.expand_path('../log', __FILE__)) do
    MiniTest::Unit.output = MiniTestReporter.new
    exit_code = MiniTest::Unit.new.run(argv) || 1
  end

  if exit_code == 0
    $stderr.puts BRIGHT_GREEN
    $stderr.puts <<-EOF.gsub(/^ {4}/, '')
      ✓✓      ✓✓ ✓✓✓✓ ✓✓    ✓✓
      ✓✓  ✓✓  ✓✓  ✓✓  ✓✓✓   ✓✓
      ✓✓  ✓✓  ✓✓  ✓✓  ✓✓✓✓  ✓✓
      ✓✓  ✓✓  ✓✓  ✓✓  ✓✓ ✓✓ ✓✓
      ✓✓  ✓✓  ✓✓  ✓✓  ✓✓  ✓✓✓✓
      ✓✓  ✓✓  ✓✓  ✓✓  ✓✓   ✓✓✓
       ✓✓✓  ✓✓✓  ✓✓✓✓ ✓✓    ✓✓
    EOF
    $stderr.puts RESET
  else
    $stderr.puts BRIGHT_RED
    $stderr.puts <<-EOF.gsub(/^ {4}/, '')
      ✘✘✘✘✘✘✘✘    ✘✘✘    ✘✘✘✘ ✘✘
      ✘✘         ✘✘ ✘✘    ✘✘  ✘✘
      ✘✘        ✘✘   ✘✘   ✘✘  ✘✘
      ✘✘✘✘✘✘   ✘✘     ✘✘  ✘✘  ✘✘
      ✘✘       ✘✘✘✘✘✘✘✘✘  ✘✘  ✘✘
      ✘✘       ✘✘     ✘✘  ✘✘  ✘✘
      ✘✘       ✘✘     ✘✘ ✘✘✘✘ ✘✘✘✘✘✘✘✘
    EOF
    $stderr.puts RESET

    $servers.each { |_,server| server.dump_log }
  end

  if ENV['HOLD_ON_A_SEC']
    print 'Holding on a sec... [Enter] '
    gets
  end
  exit exit_code
end

if __FILE__ == $0
  main(ARGV)
end
